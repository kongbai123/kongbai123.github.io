{"meta":{"title":"周晓钢的知识崖","subtitle":"zhouxg","description":"知识崖","author":"xiaogang zhou","url":"http://yoursite.com"},"pages":[{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2019-01-30T06:58:49.967Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"为何建站在我年轻的时候，独立站长曾是一个牛逼闪闪的角色，然而…so,这个网站主要是为了记录自我学习技术成长的点滴，当然装逼也是一个目的。 为何写写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 显然，写作是个艺术活儿，这个博客是带有某种程序员感情的，如果你是这种艺术家，那就能共震了！ 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。如有兴趣，欢迎一起码字。 关于作者斜杠中年、文字控、周杰伦迷，就职于粗粮厂的90后程序猿。目前致力于Java,SpringBoot,SpringCloud等大法。鸡汤一站，请自取一篇饮。 如果您遇到麻烦或对本站有疑问，请在本站找到那个白色❓号并点击查看,当然你或许找不到… 没时间再解释了，赶紧上车…"},{"title":"分类","date":"2018-10-17T06:10:04.000Z","updated":"2019-01-30T06:58:49.759Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 Welcome to 药材ggg"},{"title":"中医药材汇总","date":"2018-10-18T03:29:24.000Z","updated":"2019-01-30T06:58:49.775Z","comments":true,"path":"yaocai/index.html","permalink":"http://yoursite.com/yaocai/index.html","excerpt":"","text":""},{"title":"伤寒论经方汇总","date":"2018-10-18T03:27:43.000Z","updated":"2019-01-30T06:58:49.737Z","comments":true,"path":"jingfang/index.html","permalink":"http://yoursite.com/jingfang/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-17T05:51:16.000Z","updated":"2019-01-30T06:58:49.995Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说："}],"posts":[{"title":"Python-003:函数式编程","slug":"python/python-003","date":"2020-01-23T01:30:10.000Z","updated":"2020-01-23T01:50:40.616Z","comments":true,"path":"Python/1579743010000.html","link":"","permalink":"http://yoursite.com/Python/1579743010000.html","excerpt":"","text":"1、Python函数式编程函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。 我们首先要搞明白计算机（Computer）和计算（Compute）的概念。 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。 而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。 对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。 1.1、高阶函数 高阶函数 说明 定义 一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 代码示例 def add(x, y, f): return f(x) + f(y) map\\reduce 总结 变量可以指向函数；函数名也是变量；函数式编程就是指这种高度抽象的编程范式。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"Python-002:高级特性","slug":"python/python-002","date":"2020-01-22T08:51:41.000Z","updated":"2020-01-23T01:28:05.826Z","comments":true,"path":"Python/1579683101000.html","link":"","permalink":"http://yoursite.com/Python/1579683101000.html","excerpt":"","text":"1、Python高级特性但是在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。 基于这一思想，我们来介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。 请始终牢记，代码越少，开发效率越高。 1.1、切片-slice 定义 正取 倒取 前11-20个数 每5个取一个 复制 L = [‘Michael’, ‘Sarah’, ‘Tracy’] L[0:2]/L[:3] L[-2:] L[10:20] L[::5] L[:] 字符串，tuple类似 12345678910111213141516171819202122def trim(str): if len(str) &gt; 0: while str[:1] == ' ': str = str[1:len(str)] while str[-1:] == ' ': str = str[0:len(str)-1] return str if trim('hello ') != 'hello': print('测试失败!')elif trim(' hello') != 'hello': print('测试失败!')elif trim(' hello ') != 'hello': print('测试失败!')elif trim(' hello world ') != 'hello world': print('测试失败!')elif trim('') != '': print('测试失败!')elif trim(' ') != '': print('测试失败!')else: print('测试成功!') 1.2、迭代定义：如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 在Python中，迭代是通过`for ... in`来完成的，而很多语言比如C语言，迭代list是通过下标完成的； Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。 默认情况下，dict迭代的是key。如果要迭代value，可以用`for value in d.values()`，如果要同时迭代key和value，可以用`for k, v in d.items()`。 由于字符串也是可迭代对象 1.3、列表生成式定义：列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 123456[x * x for x in range(1, 11)][x * x for x in range(1, 11) if x % 2 == 0][m + n for m in 'ABC' for n in 'XYZ'] 总结：运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。 1.4、生成器定义：通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。 而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list， 从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： 1.5、迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： &gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance([], Iterable) True &gt;&gt;&gt; isinstance({}, Iterable) True &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) True &gt;&gt;&gt; isinstance((x for x in range(10)), Iterable) True &gt;&gt;&gt; isinstance(100, Iterable) False 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象： &gt;&gt;&gt; from collections import Iterator &gt;&gt;&gt; isinstance((x for x in range(10)), Iterator) True &gt;&gt;&gt; isinstance([], Iterator) False &gt;&gt;&gt; isinstance({}, Iterator) False &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator) False 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： &gt;&gt;&gt; isinstance(iter([]), Iterator) True &gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator) True 你可能会问，为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 小结 凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()函数实现的，例如： for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于： # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"Python-001:基础学习","slug":"python/python-001","date":"2020-01-21T06:00:36.000Z","updated":"2020-01-22T08:01:52.894Z","comments":true,"path":"Python/1579586436000.html","link":"","permalink":"http://yoursite.com/Python/1579586436000.html","excerpt":"","text":"1、Python基础1.1、使用list和tuple list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。 比较 list tuple 可变 指向不可变 [‘Michael’, ‘Bob’, ‘Tracy’] (‘a’, ‘b’, [‘A’, ‘B’]) append(),insert(),pop() 无 s[2][1] 多维数组 s[2][1] 子元素可变 2、条件判断 根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。12345678910111213141516171819202122232425262728age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') # input s = input('birth: ')birth = int(s)if birth &lt; 2000: print('00前')else: print('00后') #测试 bmi = weight/(height*height)if bmi&lt;18.5: print('过轻')elif 18.5&lt;bmi&lt;25: print('正常')elif 25&lt;=bmi&lt;28: print('过重')elif bmi&lt;32: print('肥胖')else: print('严重肥胖') 注：只要参数是非零数值、非空字符串、非空list等，就判断为True，否则为False 3、循环 1、Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子： 123names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) 2、第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 循环是让计算机做重复任务的有效的方法。 break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。 4、dict Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 list和dict比较 list dict 查找和插入的时间随着元素的增加而增加,占用空间小，浪费内存很少 查找和插入的速度极快，不会随着key的增加而变慢,需要占用大量的内存，内存浪费多。 用时间来换取空间的一种方法 用空间来换取时间的一种方法。 再议不可变对象 对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 总结 使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。 2、Python函数2.1、调用函数2.2、定义函数定义：在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 2.3 函数的参数定义：定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。 对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。 Python的函数定义非常简单，但灵活度却非常大。 除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 总结 2.4、递归函数定义：在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"IDEA-001:常用插件","slug":"IDEA/IDEA-001","date":"2019-04-12T02:00:36.000Z","updated":"2019-04-12T02:14:31.496Z","comments":true,"path":"IDEA/1555034436.html","link":"","permalink":"http://yoursite.com/IDEA/1555034436.html","excerpt":"","text":"一、常用插件推荐1、Alibaba公司出品 Alibaba Clound ToolkitAlibaba Java Coding Guidelines 2、其他个人 Background Image Plus 背景图片CodeGlance 右侧代码框Free MyBatis Plugin mapper与xml映射Grep Console 控制台日志颜色Lombok 减少代码量","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/categories/IDEA/"}],"tags":[]},{"title":"Docker01:常用命令","slug":"Docker/Docker01-启动各个容器","date":"2018-12-11T06:25:36.000Z","updated":"2019-01-31T02:48:36.285Z","comments":true,"path":"Docker/1544509536.html","link":"","permalink":"http://yoursite.com/Docker/1544509536.html","excerpt":"","text":"1、启动容器：Mysql 在docker仓库中搜索mysql的镜像：docker search mysql下载镜像：docker pull mysql查看本地镜像：docker images -a a. 参数-a 表示所有b. 启动 mysql 容器，并进入 shell 命令交互界面：docker run -it mysql /bin/bash( 参数-i -t等价于 -it 表示insert, 进入 ; /bin/bash 表示 shell 脚本交互界面 )c. 可用 mysql --help | grep Distrib 查看 mysql 版本信息（mysql --help查看帮助信息，并在结果集中 查找 Distrib ，“|”单竖线表示命令的连续执行，同时以前一个命令值域作为后一个命令的定义域 ） 2. 退出当前交互窗口：exit 此操作会关闭 mysql 服务 。 对于创建的bush 容器，exit 退出后，容器也会退出。这是因为对Docker 来说，容器中的应用退出了，容器也就没有必要继续运行了.想要服务一直运行可以：docker run -p 3306:3306 --name JY_mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql（参数 -p 设置端口，–name 取名 ，-e MYSQL_ROOT_PASSWORD=123456设置 账号为 root ，密码为 123456 ，-d 表示作为一个守护进程在后台运行 ） 3. 查看运行中的容器： docker ps（可加参数 -a 表示所有，如果不加这个参数只会展示运行状态的容器，按容器即服务的思想，某种程度上可以把容器也当作服务，）这样 mysql 就已安装并成功启动，处于运行状态了。可以通过docker port容器name 查看对应端口： 4.自定义文件地址配置 ，可以在运行容器时设置 ： docker run -p 3306:3306 --name mysql -v $PWD/conf/my.cnf:/etc/mysql/my.cnf -v $PWD/logs:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d mysql但要求对应路径对应文件已存在，才能成功挂载相内容到对应位置。命令说明：-p 3306:3306：将容器的3306端口映射到主机的3306端口-v $PWD/conf/my.cnf:/etc/mysql/my.cnf：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf-v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs-v $PWD/data:/mysql_data：将主机当前目录下的data目录挂载到容器的/mysql_data-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[]},{"title":"Docker00:常用命令","slug":"Docker/Docker00-常用命令","date":"2018-12-11T03:48:16.000Z","updated":"2019-01-31T02:41:27.465Z","comments":true,"path":"Docker/1544500096.html","link":"","permalink":"http://yoursite.com/Docker/1544500096.html","excerpt":"","text":"下面就使用docker的一些常用命令具体详细说明 一、Dcoker 相关的系统设置1、CentOS7使用firewalld打开关闭防火墙与端口 1、firewalld的基本使用启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld2、关闭SELinux临时关闭SELinuxsetenforce 0临时打开SELinuxsetenforce 1查看SELinux状态getenforce开机关闭SELinux编辑/etc/selinux/config文件，将SELINUX的值设置为disabled。下次开机SELinux就不会启动了注意，此时也不能通过setenforce 1命令临时打开 二、Docker命令1、docker的启动、停止、重启123[root@localhost ~]# service docker restart[root@localhost ~]# service docker stop[root@localhost ~]# service docker start 2、docker创建一个容器123456[root@localhost ~]# docker run -it -v /docker_test:/yufei --name yufei_6 centos[root@724e7701f0d4 /]# -i：允许我们对容器内的 (STDIN) 进行交互 -t：在新容器内指定一个伪终端或终端 -v：是挂在宿机目录， /docker_test是宿机目录，/yufei是当前docker容器的目录，宿机目录必须是绝对的。 --name：是给容器起一个名字，可省略，省略的话docker会随机产生一个名字 3、docker启动的容器列表12345[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES724e7701f0d4 centos &quot;/bin/bash&quot; 4 minutes ago Up 4 minutes yufei_6f9097691663e centos &quot;/bin/bash&quot; 5 minutes ago Up 5 minutes yufei_5[root@localhost ~]# 4、查看docker创建的所有容器 docker ps 默认列表是正在启动的容器 -a是显示所有创建的容器 123456789[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES724e7701f0d4 centos &quot;/bin/bash&quot; 5 minutes ago Up 5 minutes yufei_6f9097691663e centos &quot;/bin/bash&quot; 6 minutes ago Up 6 minutes yufei_5e59a540fb979 centos &quot;/bin/base&quot; 6 minutes ago Created yufei_4ff49dfedea4f centos &quot;/bin/bash&quot; 2 hours ago Exited (137) 10 minutes ago yufei_03d2cc70abb5a5 centos &quot;/bin/bash&quot; 2 hours ago Exited (127) 2 hours ago yufei_022d48fc5b7c17 centos &quot;/bin/bash&quot; 2 hours ago Exited (127) 2 hours ago yufei_01[root@localhost ~]# 5、启动、停止、重启某个docker 容器1234[root@localhost ~]# docker start yufei_01[root@localhost ~]# docker stop yufei_01[root@localhost ~]# docker restart yufei_01[root@localhost ~]# 6、查看指定容器的日志记录1234[root@localhost ~]# docker logs -f yufei_01[root@2d48fc5b7c17 /]# lsanaconda-post.log bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var上面红色部分是日志命令部分。 7、删除某个容器，若正在运行，需要先停止1234[root@localhost ~]# docker rm yufei_01[root@localhost ~]# docker stop yufei_01[root@localhost ~]# docker rm yufei_01[root@localhost ~]# 8、删除所有容器1[root@localhost ~]# docker rm $(docker ps -a -q) Docker相关博客 安装Docker1: https://blog.csdn.net/yinlell/article/details/83748945安装Docker2：https://blog.csdn.net/wangfei0904306/article/details/62046753","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[]},{"title":"Maven-00:Pom文件详解","slug":"maven/00-Pom文件详解","date":"2018-12-10T09:10:51.000Z","updated":"2019-01-31T02:30:41.616Z","comments":true,"path":"Maven/1544433051.html","link":"","permalink":"http://yoursite.com/Maven/1544433051.html","excerpt":"","text":"Pom文件详解如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd \"&gt; &lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!-- 被继承的父项目的构件标识符 --&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;!-- 被继承的父项目的全球唯一标识符 --&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;!-- 被继承的父项目的版本 --&gt; &lt;version&gt;xxx&lt;/version&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。 Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置）， 然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath&gt;xxx&lt;/relativePath&gt; &lt;/parent&gt; &lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的， 这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt; 4.0.0 &lt;/modelVersion&gt; &lt;!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID 和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven 为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt; jar &lt;/packaging&gt; &lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt; 1.0-SNAPSHOT &lt;/version&gt; &lt;!-- 项目的名称, Maven产生的文档用 --&gt; &lt;name&gt; xxx-maven &lt;/name&gt; &lt;!-- 项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt; http://maven.apache.org &lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略， 就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的 索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt; A maven project to study maven. &lt;/description&gt; &lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven&gt;&lt;/maven&gt; &lt;/prerequisites&gt; &lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!-- 问题管理系统（例如jira）的名字， --&gt; &lt;system&gt; jira &lt;/system&gt; &lt;!-- 该项目使用的问题管理系统的URL --&gt; &lt;url&gt; http://jira.baidu.com/banseon &lt;/url&gt; &lt;/issueManagement&gt; &lt;!-- 项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!-- 持续集成系统的名字，例如continuum --&gt; &lt;system&gt;&lt;/system&gt; &lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!-- 传送通知的途径 --&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- 发生错误时是否通知 --&gt; &lt;sendOnError&gt;&lt;/sendOnError&gt; &lt;!-- 构建失败时是否通知 --&gt; &lt;sendOnFailure&gt;&lt;/sendOnFailure&gt; &lt;!-- 构建成功时是否通知 --&gt; &lt;sendOnSuccess&gt;&lt;/sendOnSuccess&gt; &lt;!-- 发生警告时是否通知 --&gt; &lt;sendOnWarning&gt;&lt;/sendOnWarning&gt; &lt;!-- 不赞成使用。通知发送到哪里 --&gt; &lt;address&gt;&lt;/address&gt; &lt;!-- 扩展配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!-- 项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!-- 邮件的名称 --&gt; &lt;name&gt; Demo &lt;/name&gt; &lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt; banseon@126.com &lt;/post&gt; &lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt; banseon@126.com &lt;/subscribe&gt; &lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt; banseon@126.com &lt;/unsubscribe&gt; &lt;!-- 你可以浏览邮件信息的URL --&gt; &lt;archive&gt; http:/hi.baidu.com/banseon/demo/dev/ &lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!-- 项目开发者列表 --&gt; &lt;developers&gt; &lt;!-- 某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!-- SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt; HELLO WORLD &lt;/id&gt; &lt;!-- 项目开发者的全名 --&gt; &lt;name&gt; banseon &lt;/name&gt; &lt;!-- 项目开发者的email --&gt; &lt;email&gt; banseon@126.com &lt;/email&gt; &lt;!-- 项目开发者的主页的URL --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager &lt;/role&gt; &lt;role&gt; Architect &lt;/role&gt; &lt;/roles&gt; &lt;!-- 项目开发者所属组织 --&gt; &lt;organization&gt; demo &lt;/organization&gt; &lt;!-- 项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt; http://hi.baidu.com/xxx &lt;/organizationUrl&gt; &lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt; -5 &lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!-- 项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;!-- 项目贡献者的全名 --&gt; &lt;name&gt;&lt;/name&gt; &lt;!-- 项目贡献者的email --&gt; &lt;email&gt;&lt;/email&gt; &lt;!-- 项目贡献者的主页的URL --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 项目贡献者所属组织 --&gt; &lt;organization&gt;&lt;/organization&gt; &lt;!-- 项目贡献者所属组织的URL --&gt; &lt;organizationUrl&gt;&lt;/organizationUrl&gt; &lt;!-- 项目贡献者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager &lt;/role&gt; &lt;role&gt; Architect &lt;/role&gt; &lt;/roles&gt; &lt;!-- 项目贡献者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;&lt;/timezone&gt; &lt;!-- 项目贡献者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。 如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!-- license用于法律上的名称 --&gt; &lt;name&gt; Apache 2 &lt;/name&gt; &lt;!-- 官方的license正文页面的URL --&gt; &lt;url&gt; http://www.baidu.com/banseon/LICENSE-2.0.txt &lt;/url&gt; &lt;!-- 项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt; repo &lt;/distribution&gt; &lt;!-- 关于license的补充信息 --&gt; &lt;comments&gt; A business-friendly OSS license &lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag&gt;&lt;/tag&gt; &lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt; http://svn.baidu.com/banseon &lt;/url&gt; &lt;/scm&gt; &lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!-- 组织的全名 --&gt; &lt;name&gt; demo &lt;/name&gt; &lt;!-- 组织主页的URL --&gt; &lt;url&gt; http://www.baidu.com/banseon &lt;/url&gt; &lt;/organization&gt; &lt;!-- 构建项目需要的信息 --&gt; &lt;build&gt; &lt;!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对 于pom.xml的相对路径。 --&gt; &lt;sourceDirectory&gt;&lt;/sourceDirectory&gt; &lt;!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会 被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory&gt;&lt;/scriptSourceDirectory&gt; &lt;!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。 该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory&gt;&lt;/testSourceDirectory&gt; &lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;!-- 被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory&gt;&lt;/testOutputDirectory&gt; &lt;!-- 使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!-- 描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!-- 构建扩展的groupId --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 构建扩展的artifactId --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 构建扩展的版本 --&gt; &lt;version&gt;&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal&gt;&lt;/defaultGoal&gt; &lt;!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在 最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为 org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素 里列出。 --&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!-- 包含的模式列表，例如**/*.xml. --&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;!-- 排除的模式列表，例如**/*.xml --&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;!-- 描述了测试相关的资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为 org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素 里列出。 --&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;!-- 描述存放测试相关的资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!-- 包含的模式列表，例如**/*.xml. --&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;!-- 排除的模式列表，例如**/*.xml --&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!-- 构建产生的所有文件存放的目录 --&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName&gt;&lt;/finalName&gt; &lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters&gt;&lt;/filters&gt; &lt;!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本 地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!-- 使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!-- 插件在仓库里的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 插件在仓库里的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 被使用的插件的版本（或版本范围） --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该 元素才被设置成enabled。 --&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!-- execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;&lt;/phase&gt; &lt;!-- 配置的执行目标 --&gt; &lt;goals&gt;&lt;/goals&gt; &lt;!-- 配置是否被传播到子POM --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- 项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 该项目使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!-- 插件在仓库里的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 插件在仓库里的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 被使用的插件的版本（或版本范围） --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该 元素才被设置成enabled。 --&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!-- execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;&lt;/phase&gt; &lt;!-- 配置的执行目标 --&gt; &lt;goals&gt;&lt;/goals&gt; &lt;!-- 配置是否被传播到子POM --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- 项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它能够 在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元 素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!-- profile默认是否激活的标志 --&gt; &lt;activeByDefault&gt;true/false&lt;/activeByDefault&gt; &lt;!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本 不是以1.4开头的JDK。 --&gt; &lt;jdk&gt;jdk版本，如:1.7&lt;/jdk&gt; &lt;!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!-- 激活profile的操作系统的名字 --&gt; &lt;name&gt; Windows XP &lt;/name&gt; &lt;!-- 激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt; Windows &lt;/family&gt; &lt;!-- 激活profile的操作系统体系结构 --&gt; &lt;arch&gt; x86 &lt;/arch&gt; &lt;!-- 激活profile的操作系统版本 --&gt; &lt;version&gt; 5.1.2600 &lt;/version&gt; &lt;/os&gt; &lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile 就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹 配属性值字段 --&gt; &lt;property&gt; &lt;!-- 激活profile的属性的名称 --&gt; &lt;name&gt; mavenVersion &lt;/name&gt; &lt;!-- 激活profile的属性的值 --&gt; &lt;value&gt; 2.0.3 &lt;/value&gt; &lt;/property&gt; &lt;!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!-- 如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt; /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!-- 如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt; /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!-- 构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;directory&gt;&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;directory&gt;&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory&gt;&lt;/directory&gt; &lt;finalName&gt;&lt;/finalName&gt; &lt;filters&gt;&lt;/filters&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;&lt;/id&gt; &lt;phase&gt;&lt;/phase&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;&lt;/id&gt; &lt;phase&gt;&lt;/phase&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的 相对路径 --&gt; &lt;modules&gt; &lt;!--子项目相对路径--&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的 仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看 到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt;&lt;/reporting&gt; &lt;!-- 参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; &lt;/distributionManagement&gt; &lt;!-- 参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules&gt; &lt;!--子项目相对路径--&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直）， daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中， 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt; banseon-repository-proxy &lt;/id&gt; &lt;!-- 远程仓库名称 --&gt; &lt;name&gt; banseon-repository-proxy &lt;/name&gt; &lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; http://192.168.1.169:9999/repository/ &lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认 的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt; default &lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。 要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 依赖的group ID --&gt; &lt;groupId&gt; org.apache.maven &lt;/groupId&gt; &lt;!-- 依赖的artifact ID --&gt; &lt;artifactId&gt; maven-artifact &lt;/artifactId&gt; &lt;!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt; 3.8.1 &lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt; jar &lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如， 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生 成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt; test &lt;/scope&gt; &lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的 依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt; spring-core &lt;/artifactId&gt; &lt;groupId&gt; org.springframework &lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。 可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!-- 所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!-- 使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!-- 报表插件在仓库里的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 报表插件在仓库里的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 被使用的报表插件的版本（或版本范围） --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 报表插件的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如， 有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报 表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;!-- 配置是否被继承到子POMs --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 这个集合里使用到哪些报表 --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖 （必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过 group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者 把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见 repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt; banseon-maven2 &lt;/id&gt; &lt;name&gt; banseon maven2 &lt;/name&gt; &lt;url&gt; file://$&#123;basedir&#125;/target/deploy &lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/repository&gt; &lt;!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见 distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt; banseon-maven2 &lt;/id&gt; &lt;name&gt; Banseon-maven2 Snapshot Repository &lt;/name&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/usr/local/maven-snapshot &lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/snapshotRepository&gt; &lt;!-- 部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt; banseon-site &lt;/id&gt; &lt;!-- 部署位置的名称 --&gt; &lt;name&gt; business api website &lt;/name&gt; &lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位 那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!-- 构件新的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 构件新的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 构件新的版本号 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message&gt;&lt;/message&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值 有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt; &lt;status&gt;&lt;/status&gt; &lt;/distributionManagement&gt; &lt;!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里 activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties&gt; &lt;name&gt;value&lt;/name&gt; &lt;/properties&gt; &lt;/project&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/categories/Maven/"}],"tags":[]},{"title":"Linux03:大数据相关配置","slug":"Linux/03-大数据相关配置","date":"2018-11-26T08:38:02.000Z","updated":"2019-07-04T04:00:06.378Z","comments":true,"path":"linux/1543221482.html","link":"","permalink":"http://yoursite.com/linux/1543221482.html","excerpt":"","text":"大数据配置1. java环境变量1234567vim /etc/profile添加如下内容：JAVA_HOME根据实际目录来export JAVA_HOME=/usr/local/src/jdk1.6.0_45export CLASSPATH=$CLASSPATH:$JAVA_HOME/libexport PATH=$PATH:$JAVA_HOME/bin//生效指令source /etc/profile 2. hadoop 配置文件修改123456mastersslavescore-site.xmlmapred-site.xmlhdfs-site.xmlhadoop-env.sh 3. 本地网络配置123192.168.183.10 master192.168.183.11 slave1192.168.183.12 slave2 4. 当前host配置12345[root@localhost sysconfig]# /etc/hosts[root@localhost sysconfig]# ls /etc/sysconfig/network[root@localhost sysconfig]# /etc/sysconfig/networkhostname master //重启后失效必须配置/etc/sysconfig/network 5. 关闭防火墙123456789101112131415[root@localhost src]# /etc/init.d/iptables stop[root@localhost conf]# setenforce 0[root@localhost conf]# getenforcePermissive推荐#查看防火墙状态service iptables status#关闭防火墙service iptables stop#查看防火墙开机启动状态chkconfig iptables --list#关闭防火墙开机启动chkconfig iptables off 6. ssh 密钥验证1234567891011//生成公私密钥[root@localhost conf]# ssh-keygen//进入隐藏目录[root@localhost conf]# cd ~/.ssh/-rw-r--r--. 1 root root 1181 Jun 12 08:54 authorized_keys-rw-------. 1 root root 1675 Jun 12 08:45 id_rsa-rw-r--r--. 1 root root 393 Jun 12 08:45 id_rsa.pub//authorized_keys保存3个公钥，然后无密码访问[root@localhost .ssh]# ssh slave1 7. 启动hadoop 集群12345678910//格式化[root@localhost bin]# ./hadoop namenode -format//启动集群[root@localhost bin]# ./start-all.sh //查询启动状态[root@localhost bin]# jps13340 SecondaryNameNode13518 Jps13191 NameNode13410 JobTracker net配置设置1. network 网络地址目录123456789101112 vim /etc/sysconfig/network-scripts/ifcfg-eth0 例如配置如下： DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;IPADDR=192.168.183.10NETMASK=255.255.255.0GATEWAY=192.168.183.2DNS1=10.8.11.27(本地DNS) 2. 共享文件夹目录地址1cd /mnt/hgfs/ 3. 远程复制1scp -rp aaa.txt 192.168.183.11:/usr/local/src/ 4. 本机hosts目录地址1234567891011121314vim /ect/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.183.10 master 192.168.183.11 slave1 192.168.183.12 slave2//临时生效hostname master//永久生效vim /etc/sysconfig/network NETWORKING=yes HOSTNAME=master 5. 集群时间同步12345678#查看时间同步状态[root@master bin]# service ntpd statusntpd is stopped#启动[root@master bin]# sudo service ntpd startStarting ntpd: [ OK ]#开机默认启动[root@master bin]# chkconfig ntpd on Zookeeper配置安装1. 进入zookeeper安装目录123456789101112131415161718192021222324[root@master zookeeper-3.4.5]# touch myid[root@master zookeeper-3.4.5]# vim myid //添加编号：0[root@master zookeeper-3.4.5]# cd conf/[root@master conf]# lsconfiguration.xsl log4j.properties zoo_sample.cfg#创建配置文件[root@master conf]# cat zoo_sample.cfg &gt; zoo.cfg#分发到各个节点[root@master src]# scp -rp zookeeper-3.4.5 slave2:/usr/local/src/#进入bin目录[root@master zookeeper-3.4.5]# cd bin/[root@slave1 bin]# ./zkServer.sh startJMX enabled by defaultUsing config: /usr/local/src/zookeeper-3.4.5/bin/../conf/zoo.cfgStarting zookeeper ... STARTED#查看状态[root@master bin]# jps50774 QuorumPeerMain 【zookeeper 进程】50906 Jps[root@master bin]# ./zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/src/zookeeper-3.4.5/bin/../conf/zoo.cfgMode: follower Storm 配置安装1. 进入storm安装目录123456789101112131415161718192021[root@master src]# cd apache-storm-0.9.3[root@master apache-storm-0.9.3]# cd conf[root@master conf]# ls[root@master conf]# vim storm.yaml storm_env.ini storm.yaml#修改配置 storm.zookeeper.servers: - &quot;master&quot; - &quot;server1&quot; - &quot;server2&quot; nimbus.host: &quot;master&quot; supervisor.slots.ports: - 6700 - 6701 - 6702 - 6703 - 6704#分发[root@master src]# scp -rp apache-storm-0.9.3 slave2:/usr/local/src/","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"}]},{"title":"springcloud-01:推荐几个Spring Cloud学习资料","slug":"springcloud/推荐几个Spring Cloud学习资料","date":"2018-11-15T07:42:02.000Z","updated":"2019-01-30T06:58:49.911Z","comments":true,"path":"springcloud/1542267722.html","link":"","permalink":"http://yoursite.com/springcloud/1542267722.html","excerpt":"","text":"博客 1.跟我学Spring Cloud 2.周立|Spring Cloud 3.Spring Cloud基础教程(强烈推荐) 4.Spring Cloud系列文章 5.forezp|史上最简单的 Spring Cloud 教程 6.liaokailin的专栏 7.Spring Cloud系列 8.关于Spring Boot 网站 1.Spring Cloud中文网[中] 2.Spring Boot参考指南-中文版[中] 3.Gradle 中文参考指南[中] 6.spring-boot-tutorials[英] 7.Spring boot 官网[英] 书1.Spring Cloud微服务实战【翟永超】","categories":[{"name":"springcloud","slug":"springcloud","permalink":"http://yoursite.com/categories/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://yoursite.com/tags/springcloud/"}]},{"title":"springboot-00:相关博客","slug":"springboot/springboot-00-相关博客","date":"2018-11-07T14:20:16.000Z","updated":"2019-01-30T06:58:49.902Z","comments":true,"path":"springboot/1541600416.html","link":"","permalink":"http://yoursite.com/springboot/1541600416.html","excerpt":"","text":"简书： 我没有三颗心脏-github： 1、SpringBoot技术栈搭建个人博客【项目准备】 2、SpringBoot技术栈搭建个人博客【后台开发】 3、SpringBoot技术栈搭建个人博客【前台开发/项目总结","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"soft-01:软件激活相关","slug":"soft/软件激活相关","date":"2018-10-31T11:00:11.000Z","updated":"2019-01-30T06:58:49.948Z","comments":true,"path":"soft/1540983611.html","link":"","permalink":"http://yoursite.com/soft/1540983611.html","excerpt":"","text":"软件激活教程 IDEA免费激活方法： 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中 IntelliJ IDEA 注册码: http://idea.lanyus.com/","categories":[{"name":"soft","slug":"soft","permalink":"http://yoursite.com/categories/soft/"}],"tags":[{"name":"激活","slug":"激活","permalink":"http://yoursite.com/tags/激活/"}]},{"title":"EAS教程：01-学习网站","slug":"EASBos/EAS001","date":"2018-10-26T09:30:36.000Z","updated":"2019-01-30T06:58:49.954Z","comments":true,"path":"Redis/1540546236.html","link":"","permalink":"http://yoursite.com/Redis/1540546236.html","excerpt":"","text":"转载博客 金蝶社区：http://club.kingdee.com/club/newclubEAS820 客户端登录一直在初始化:http://club.kingdee.com/forum.php?mod=viewthread&amp;tid=1126950webService 发送soap请求，并解析返回的soap报文 :链接【精华合辑】EAS服务支持知识大放送: http://club.kingdee.com/forum.php?mod=viewthread&amp;tid=1022125 EASBOS WebService 使用EAS-webserivce规范及流程： https://blog.csdn.net/douml88/article/details/52689353在EAS BOS上挂菜单，主菜单管理上看不到菜单目录： 链接EAS BOS中如何以模式窗口打开新界面: https://blog.csdn.net/wiser/article/details/38536269EAS-BOS常用控件属性方法事件: BOS自带服务器只显示一条数据记录: 名人博客 语不惊人死不休: https://blog.csdn.net/qiaqia609/article/category/1346596giianhui的专栏: https://blog.csdn.net/giianhui/article/category/753253","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[]},{"title":"Redis教程：00-安装单机版redis","slug":"Redis/Redis-00","date":"2018-10-26T09:18:04.000Z","updated":"2019-01-30T06:58:49.940Z","comments":true,"path":"Redis/1540545484.html","link":"","permalink":"http://yoursite.com/Redis/1540545484.html","excerpt":"","text":"1.redis下载 官网地址: https://redis.io/download 2.解压1[root@MiWiFi-R3-srv local]# tar -zxvf ~/redis-4.0.2.tar.gz -C . 3.安装123456[root@MiWiFi-R3-srv local]# yum install -y gcc-c++[root@MiWiFi-R3-srv local]# cd redis-4.0.2/[root@MiWiFi-R3-srv redis-4.0.2]# make[root@MiWiFi-R3-srv redis-4.0.2]# make install PREFIX=/usr/local/redis[root@MiWiFi-R3-srv redis-4.0.2]# cp redis.conf /usr/local/redis/bin/[root@MiWiFi-R3-srv redis-4.0.2]# cd /usr/local/redis/bin/ 4.配置redis-conf1[root@MiWiFi-R3-srv bin]# vim redis.conf 修改以下内容(设置后台运行redis): daemonize yes 设置任何地址可以访问redis bind 0.0.0.0 5.启动redis1[root@MiWiFi-R3-srv bin]# ./redis-server redis.conf 6.设置开机自启动1[root@MiWiFi-R3-srv bin]# vim /etc/rc.local 在rc.local文件末尾添加以下内容: /usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf 7.测试1.1出现以下信息,说明服务端启动成功:123[root@MiWiFi-R3-srv bin]# ps aux|grep redisroot 2713 0.1 0.4 145260 7536 ? Ssl 12:57 0:00 /usr/local/redis/bin/redis-server 127.0.0.1:6379root 2811 0.0 0.0 112668 964 pts/0 S+ 12:58 0:00 grep --color=auto redis 1.2测试客户端连接 服务端返回PONG说明连接成功 1234[root@MiWiFi-R3-srv bin]# ./redis-cli 127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; 至此,redis的安装和配置就完成了!!!","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[]},{"title":"Redis教程：01-Redis4集群搭建","slug":"Redis/Redis-01","date":"2018-10-26T08:01:58.000Z","updated":"2019-01-30T06:58:49.941Z","comments":true,"path":"Redis/1540540918.html","link":"","permalink":"http://yoursite.com/Redis/1540540918.html","excerpt":"","text":"转载博客 Redis入门篇（安装与启动）（一） Redis4集群搭建","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[]},{"title":"Nginx教程：04-负载均衡","slug":"Nginx/Nginx04","date":"2018-10-26T06:52:46.000Z","updated":"2019-01-30T06:58:49.882Z","comments":true,"path":"Nginx/1540536766.html","link":"","permalink":"http://yoursite.com/Nginx/1540536766.html","excerpt":"","text":"1.准备环境12[root@MiWiFi-R3-srv ~]# cp -r apache-tomcat-8.5.23 tomcat03[root@MiWiFi-R3-srv ~]# vim tomcat03/conf/server.xml #第22行,修改为8007 &lt;Server port=&quot;8007&quot; shutdown=&quot;SHUTDOWN&quot;&gt; #第69行,修改为8082 &lt;Connector port=&quot;8082&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; #第116行,修改为8011 &lt;Connector port=&quot;8011&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 2.配置负载均衡 如果一个服务由多个服务器提供,需要把负载分配到不同的服务器处理,需要做负载均衡; upstream tomcat01 { server 192.168.10.1:8080; #添加一个server即可 server 192.168.10.1:8082; } 重新加载配置文件 1[root@MiWiFi-R3-srv ~]# /usr/local/nginx/sbin/nginx -s reload 访问域名 ctrl+f5 强制刷新可以看到每次都是不同的服务器提供服务 3.权重 可以根据服务器的实际情况调整服务器的权重,权重越高分配的请求越多,权重越低请求越少,默认都是1;1.轮询(默认) 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 2.weight( 默认为:1 weight越大，负载的权重就越大) 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况 upstream tomcat01 { server 192.168.10.1:8080; server 192.168.10.1:8082 weight=2; } nginx配置负载均衡 ok!","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[]},{"title":"Nginx教程：03-反向代理","slug":"Nginx/Nginx03","date":"2018-10-26T06:04:45.000Z","updated":"2019-01-30T06:58:49.881Z","comments":true,"path":"Nginx/1540533885.html","link":"","permalink":"http://yoursite.com/Nginx/1540533885.html","excerpt":"","text":"1.nginx配置反向代理 两个域名指向同一台nginx服务器 ,用户访问不同的域名显示不同的内容; 两个域名:www.zhou01.com 和 www.zhou02.com nginx服务器使用的虚拟机: 192.168.10.1 2.安装环境2.1 安装tomcat 官网下载链接: https://tomcat.apache.org/download-80.cgi1[root@MiWiFi-R3-srv ~]# tar -zxvf apache-tomcat-8.5.23.tar.gz 2.2 安装两个tomcat,分别运行8080和8081端口123[root@MiWiFi-R3-srv ~]# cp -r apache-tomcat-8.5.23 tomcat01[root@MiWiFi-R3-srv ~]# cp -r apache-tomcat-8.5.23 tomcat02[root@MiWiFi-R3-srv ~]# vim tomcat02/conf/server.xml #第22行,修改为8006 &lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt; #第69行,修改为8081 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; #第116行,修改为8010 &lt;Connector port=&quot;8010&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 2.3 启动两个tomcat12[root@MiWiFi-R3-srv ~]# tomcat01/bin/startup.sh[root@MiWiFi-R3-srv ~]# tomcat02/bin/startup.sh 3.反向代理服务器的配置#添加upstream模块,tomcat01和proxy_pass后面名字相同 upstream tomcat01 { server 192.168.10.1:8080; } 添加upstream模块tomcat02和proxy_pass后面名字相同 upstream tomcat02 { server 192.168.10.1:8081; } server { listen 80; #配置域名 server_name www.zhou01.com; location / { #配置proxy_pass代理转发 proxy_pass http://tomcat01; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } server { listen 80; #配置域名 server_name www.zhou02.com; location / { #配置proxy_pass代理转发 proxy_pass http://tomcat02; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 4.启动nginx1[root@MiWiFi-R3-srv ~]# /usr/local/nginx/sbin/nginx -s reload 5.配置域名在windows的hosts文件中添加域名和ip的映射关系 192.168.10.1 www.zhou01.com 192.168.10.1 www.zhou02.com 6.访问域名 完成!","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[]},{"title":"Nginx教程：02-安装部署","slug":"Nginx/Nginx02","date":"2018-10-26T02:38:44.000Z","updated":"2019-01-30T06:58:49.880Z","comments":true,"path":"Nginx/1540521524.html","link":"","permalink":"http://yoursite.com/Nginx/1540521524.html","excerpt":"","text":"1.下载nginx nginx官网:http://nginx.org/ &gt; stable version代表稳定版 2.安装环境2.1 gcc环境1[root@MiWiFi-R3-srv ~]# yum -y install gcc-c++ 2.2 第三方开放包Perl库1[root@MiWiFi-R3-srv ~]# yum -y install pcre pcre-devel 2.3 zlib库1[root@MiWiFi-R3-srv ~]# yum -y install zlib zlib-devel 2.4 openssl1[root@MiWiFi-R3-srv ~]# yum -y install openssl openssl-devel 以上所有安装命令合并成一条命令:1[root@MiWiFi-R3-srv ~]# yum -y install gcc-c++ &amp;&amp; yum -y install pcre pcre-devel &amp;&amp; yum -y install zlib zlib-devel &amp;&amp; yum -y install openssl openssl-devel 3.安装nginx3.1 解压缩12[root@MiWiFi-R3-srv ~]# tar -zxvf nginx-1.8.0.tar.gz[root@MiWiFi-R3-srv ~]# cd nginx-1.8.0 3.2 使用configure创建一个makeFile文件123456789101112./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi 3.3 编译安装nginx1[root@MiWiFi-R3-srv nginx-1.8.0]# make &amp;&amp; make install 4.启动nginx4.1 进入sbin目录启动nginx12[root@MiWiFi-R3-srv nginx-1.8.0]# cd /usr/local/nginx/sbin/[root@MiWiFi-R3-srv sbin]# ./nginx 4.3 ps命令查看nginx启动进程12345[root@MiWiFi-R3-srv sbin]# ps aux|grep nginxroot 13875 0.0 0.0 24840 768 ? Ss 23:13 0:00 nginx: master process ./nginxnobody 13876 0.0 0.1 25268 1480 ? S 23:13 0:00 nginx: worker processroot 13881 0.0 0.0 112664 964 pts/0 R+ 23:14 0:00 grep --color=auto nginx[root@MiWiFi-R3-srv sbin]# 4.4 nginx的常用操作命令4.4.1 关闭nginx命令1./nginx -s stop 推荐使用: 1./nginx -s quit 4.4.2 重启nginx命令(刷新配置文件)命令流程: 先关闭 &gt; 后启动 &gt; 刷新配置文件 1./nginx -s reload 5.访问nginx默认端口:80 注意:是否关闭防火墙 5.1 打开80端口1234[root@MiWiFi-R3-srv sbin]# firewall-cmd --zone=public --add-port=80/tcp --permanentsuccess[root@MiWiFi-R3-srv sbin]# firewall-cmd --reloadsuccess 5.2 访问nginx 至此! nginx的安装及启动就完成了!!!","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[]},{"title":"Nginx教程：01-介绍","slug":"Nginx/Nginx01","date":"2018-10-26T01:16:00.000Z","updated":"2019-01-30T06:58:49.879Z","comments":true,"path":"Nginx/1540518470.html","link":"","permalink":"http://yoursite.com/Nginx/1540518470.html","excerpt":"","text":"1、Nginx的功能特性 基本Http服务，可以作为Http代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL 高级Http服务，可以进行自定义配置，支持虚拟主机，支持URL重定向，支持网络监控，支持流媒体传输等 邮件代理服务器，支持IMAP/POP3代理服务功能，支持内部SMTP代理服务功能 1.1、基本HTPP服务 处理静态文件，如HTML网页以及请求 打开并自行管理文件描述符缓存 提供反向代理服务，并且可用缓存加速反向代理 提供远程FastCGI（通用网关接口）服务的缓存机制 模块化提供过滤器功能，gzip压缩 ranges支持 chunked响应 XSLT SSI 图像缩放 针对包含多个SSI的页面，经由反向代理SSI过滤器可并行处理 支持安全套接协议SSL 1.2、高级HTTP服务 支持基于名字和IP的虚拟主机设置 支持HTTP/1.0 中的keep-alive模式和管线模型(PipelLined)连接 支持重新升级时，无需中断正在处理的请求 自定义访问日志格式、带缓存的日志写操作以及快速日志轮转 提供3xx 5xx错误代码重定向功能 支持重写模块扩展 支持HTTP DAV模块，从而为HTTP DAV模块提供PUT DELETE MKCOL COPY MOVE方法 支持FLV流和MP4流传输 支持网络监控，访问控制、速度限制或请求限制等 支持嵌入perl语言 1.3、邮件代理服务 支持使用外部HTTP认证服务器重定向用户到IMAP/POP3后端，并支持IMAP认证方式和POP3认证方式 支持使用外部HTTP认证服务器器认证用户后重定向连接到内部SMTP后端，并支持SMTP认证方式 支持邮件代理服务下的安全套接层安全协议SSL 支持纯文本通信协议的扩展协议STARTTLS 1.4、常用功能 HTTP代理和反向代理 请求稳定，后端转发与业务配合分离，配置灵活，支持判断表达式 负载均衡 将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后将结果汇总给用户提高网络系统的处理能力 将大量的前端并发访问或者数据流量分担到多个后端网络节点上分别处理 nginx的负载均衡策略 内置策略:轮询 加权轮询 IP HASH 扩展策略 主要通过第三方模块实现，常见有url hash WEB缓存 主要由Proxy_Cache(提供代理服务时，对后端服务器返回内容进行URL缓存) 和FastCGI_Cache(对FastCGI程序缓存)指令集构成","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[]},{"title":"Linux01:常用linux命令","slug":"Linux/01-常用Linux命令","date":"2018-10-25T03:15:14.000Z","updated":"2019-01-30T06:58:49.931Z","comments":true,"path":"linux/1540430457.html","link":"","permalink":"http://yoursite.com/linux/1540430457.html","excerpt":"","text":"1.查看文件头部前十行-列表格式化显示1cat ip.lib.txt |head|column -t 2.查看文件大小 Linux wc命令用于计算字数。利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 1234567891011语法wc [-clw][--help][--version][文件...]参数：-c或--bytes或--chars 只显示Bytes数。-l或--lines 只显示行数。-w或--words 只显示字数。--help 在线帮助。--version 显示版本信息。实例在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：wc testfile 3.查看当前目录下文件大小123456789[root@master src]# du -sh *24M apache-storm-0.9.315G hadoop-1.2.160M hbase-0.98.24-hadoop1206M jdk1.6.0_45369M jdk1.8.0_18111M storm_demo24M zhou48M zookeeper-3.4.5 4.在当前目录下查找文件12 shell 命令 重启网络服务 123cd /etc/sysconfig/network-scripts/vim ifcfg-eth0cd /etc/init.d/network restart 共享目录 1cd /mnt/hgfs/ 复制文件到指定目录 1cp XXX /usr/local/src 安装运行 1./XXX Linux的环境变量12345使用方法举例：vim ~/.bashrc执行后 ~/.bashrc 中的内容立即生效。$. ~/.bashrc 6.新增目录 1mkdir tmp 7.解压压缩包 1234#压缩文件tar cvzf w.tar.gz white_list_*#解压文件tar xvzf hadoop-1.2.1-bin.tar.gz 排序(修改时间)查询目录下的文件 1ls -rlt 查看文件格式 1file xxx 代码打开文件 12345678import sysfile = sys.argv[1]with open(file,'r') as fd: for line in fd: print line,strip()#执行-输出run.sh内容python 1.py run.sh 11.同步系统时间1234//复制相应的时区文件，替换系统时区文件；或者创建链接文件cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime//例如：在设置中国时区使用亚洲/上海（+8）cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux02:CenOs7安装","slug":"Linux/02-CenOS7安装","date":"2018-10-25T03:15:14.000Z","updated":"2019-04-12T02:02:52.597Z","comments":true,"path":"linux/1540430457.html","link":"","permalink":"http://yoursite.com/linux/1540430457.html","excerpt":"","text":"1.查看文件头部前十行-列表格式化显示关于JDK1.8 与之前的版本相比有哪些变化和新特性我也不在这详细的说明了,毕竟一度娘啥都有了,既然不多说那就直接开始吧!! 准备资料: 1、已经在VMware安装好了的虚拟机,本文使用的是CentOS7,我就以这个为例,如果又不知道怎么安装的朋友可以参考我第一篇文章,上面详细的介绍了如何安装CentOS7 下载安装centos7 2、jdk:jdk-8u11-linux-x64.tar.gz 官网下载jdk8 3、xshell 远程操作虚拟机工具 xshell的下载与安装请参考我上一篇文章(为什么要用到它来操作,因为我觉得它操作简单又是免费的.) 下载安装 xshell OK，资料已准备好了，现在可以开始了 通过xshell工具成功连接安装好的虚拟机之后可通过 rpm -qa | grep java 或 rpm -qa | grep jdk 命令来查询出系统自带的jdk（带箭头的四个就是系统自带的）注：不带箭头的那三个不要删掉 然后通过 rpm -e --nodeps 后面跟系统自带的jdk名 这个命令来删除系统自带的jdk， 例如：1234rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 删完之后可以再通过 rpm -qa | grep java 或 rpm -qa | grep jdk 命令来查询出是否删除掉 接下来就是要安装自己的jdk了，通过命令 cd /usr/local/ 进入local目录，并通过 ll（两个小写的L）命令或者 ls 命令（ ll 本身不是命令，只是 ls -l 命令的一个别名，不过无所谓了，都是一样查看的）列出当前目录下得所有非隐含的文件，如果想要看到隐含（以 . 开头的，如 .test.txt）文件信息可通过 ll -a 来查看 进入local目录之后 通过 mkdir java 命令来创建java目录存放自己的jdk （扩展：如果你想一次性在同一级目录下创建多个平级的目录可以通过 mkdir brother1 brother2 (如要创建更多就在后面加上去就可以了，中间用空格隔开)这样的命令来创建，如果要一次创建父子目录（parent/child）可以通过 mkdir -p parent/child/grandson 来创建） 创建好之后，进入java目录 cd java 不知道大家有没有用过 在线导入安装包的插件，如果之前没有用过可以通过 yum -y install lrzsz 命令安装这个插件 安装插件完成之后输入 rz 命令然后按回车，就会弹出一个窗口，然后你就在这个窗口找到你下载好的jdk， 注：使用 rz 命令的好处就是你在哪里输入rz导入的安装包他就在哪里，不会跑到根目录下 双击jdk或者按打开之后就会进入传输的界面 有时会出现下面这样的问题，如果出现请关闭该窗口重新输入 rz 命令按回车 这个就是正常的了 传输完成之后 ll 命令 查看 通过 tar -zxvf {安装包名} 命令解压jdk 如：tar -zxvf jdk-8u11-linux-x64.tar.gz 我个人比较喜欢把 zxvf 转成中文念，叫 “至小威风” 这样我觉得方便记，不喜勿喷哦 解压过后出现如下画面 这时安装包已经没用了，我一般都会删掉安装包 通过 rm -f jdk-8u11-linux-x64.tar.gz 删除安装包 -f 的意思就是 不询问删除 如果你不加 -f 在删除时它会询问你是否要删除该安装包，我是确定要删了就加上 -f 了。说到这里那我顺便说说 递归删除不询问 的命令吧，在什么情况下使用该命令呢，如果你要删除一个目录，而这个目录下还有目录或者有文件，比如在parent/child/grandson 这样的目录下你要删除 parent 下得所有目录和文件（包括parent）就可以用到 rm -rf parent 命令就可以删除掉了 删掉安装包之后就开始配置环境变量了 通过 vim /etc/profile 命令打开 profile 文件盘配置环境变量 打开之后按 i 进入 insert （插入）模式，在文件末尾添加上环境变量123export JAVA_HOME=/usr/local/java/jdk1.8.0_11export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 添加完之后保存并退出，保存并退出的命令有两种 第一种是： 按住shift 键然后连按两次z（这是我常用的，因为它方便快速），第二种是：wq 命令，有一种是不保存退出的命令：q ，注意：以上三种命令都是在非插入模式（插入模式下按键盘左上角的ESC键退出插入模式就是非插入模式了）下操作。 保存完之后输入：source /etc/profile 命令使刚才配置的环境变量生效 现在就可以测试jdk了 输入 javac 命令如果出现以下的文字就说明编译成功了（如果你之前安装centos7时使用的语言是英文，那出现的就是类似这样排版的英文） 接下来我们通过 java -version命令来查看你安装的jdk信息 如果出现以上信息就说明你自己的jdk就完全安装成功了，如果有什么问题可以在评论下留言，我看到会第一时间回复如果此文章有什么不对的地方请路过的大神指出，以免误人子弟 尊重原创，如要转载请注明出处 作者：hui_2016来源：CSDN原文：https://blog.csdn.net/hui_2016/article/details/69941850版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Hexo 主题bubuzou教程","slug":"other/README","date":"2018-10-17T06:46:15.000Z","updated":"2019-01-30T06:58:49.828Z","comments":true,"path":"Readme/1540430457.html","link":"","permalink":"http://yoursite.com/Readme/1540430457.html","excerpt":"","text":"更新日志2017-07-21 bubuzou.css 规范化了css文件 2017-07-12 评论系统由网易云跟帖改成了畅言 2017-06-25 增加了文章访问次数的统计功能 2017-06-07 文章目录优化，能够自适应定位 说明hexo-theme-bubuzou主题是根据hexo里Apollo主题改编而来的，主题效果 安装想要把hexo的主题应用到自己的博客上，需要在本地先构建好hexo所依赖的环境。hexo使用文档大致的步骤是这样的： 安装git 安装node.js 安装hexo 1$ npm install -g hexo-cli 构建站点 123$ hexo init d://Blog$ cd d://Blog$ npm install clone主题这个时候已经构建好了站点，但是使用的主题是hexo默认的landscape。所以如果需要变更为bubuzou主题，就需要从github上clone到本地，修改文件名为bubuzou，并且放到d://Blog/theme下hexo-theme-bubuzou主题 修改主题然后把blog目录下的_config.yml配置文件里的theme: landscape改成bubuzou即可 安装依赖包hexo里每个不同的主题所依赖的包都不尽相同。安装的默认主题已经包含了一些依赖包，但是对于bubuzou这个主题来说是不够的，所以还需要安装以下几个: 12npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archivenpm install --save hexo-deployer-git hexo-generator-json-content hexo-generator-search 主题说明文档 中文文档","categories":[{"name":"Readme","slug":"Readme","permalink":"http://yoursite.com/categories/Readme/"}],"tags":[]},{"title":"详细语法","slug":"other/doc-zh","date":"2018-10-17T06:46:15.000Z","updated":"2019-01-30T06:58:49.825Z","comments":true,"path":"Readme/1540430457.html","link":"","permalink":"http://yoursite.com/Readme/1540430457.html","excerpt":"","text":"文章变量文章变量可以定义在md文件的开头。可以定义文章的标题，时间，归档的标签，归档的分类，文章关键字，文章描述，文章出处以及文章的示例等。 123456789title: background属性date: 2017-3-10 11:19:04tags: cssdesc: css的复合属性background，以及background-repeat,background-position,background-origin等子属性的介绍。keywords: css background、background-repeat、background-position、background-origincategories: - cssfrom: https://bitsofco.de/the-background-properties/demo: ../../../demos/201703/background.html 标题实际上，Hexo-theme-bubuzou 只支持两种标题：h2 一级标题，h3 二级标题，也就是分别使用 ## 和 ### 来表示。之所以这么处理，是因为就个人感觉而言，我们不应该为文章设置过多的层级消耗读者的阅读精力。配置了这样的标题的页面会自动生成页面目录。 文章摘要如果你想创建文章摘要用于向读者展示文章的核心内容，那么需要在文章摘要之后其他内容之前添加 HTML 注释标签 &lt;!--more--&gt;，使用方法如下图所示： 评论插件Hexo-theme-bubuzou 评论插件由最开始的多说改成网易云跟帖，后面由于8月1号云跟帖暂停服务，所以现在又换成了畅言。请在 theme/_config.yml 文件中做如下配置: 1changyan: bubuzou 警告块使用警告块需要 div 标签和 tip 类名： 123&lt;div class=\"tip\"&gt; 在ECMAScript 5的strict模式下，这种情况的`this`已经被规定不会指向全局对象了，而是`undefined`&lt;/div&gt; 搜索使用搜索功能需要在站点的配置文件_config.yml里配置如下：1234# searchsearch: path: search.xml field: post 归档页面显示所有文章需要安装hexo-generator-archive插件支持，然后在全局的_config.yml里配置：12345archive_generator: per_page: 0 yearly: false monthly: false daily: false 访问次数统计引入js脚本：12&lt;script src=&quot;https://cdn1.lncld.net/static/js/av-mini-0.6.10.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js&quot;&gt;&lt;/script&gt; 显示当前页面的访问量：1&lt;span data-hk-page=&quot;current&quot;&gt; - &lt;/span&gt; 显示指定页面的访问量： - 注意这里的链接必须是带协议的完整链接，而且不能带中文的。更多用法可以参考这里","categories":[{"name":"Readme","slug":"Readme","permalink":"http://yoursite.com/categories/Readme/"}],"tags":[]},{"title":"Hello World","slug":"other/hello-world","date":"2018-10-12T06:38:02.000Z","updated":"2019-01-30T06:58:49.826Z","comments":true,"path":"未分类/1447295415.html","link":"","permalink":"http://yoursite.com/未分类/1447295415.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}